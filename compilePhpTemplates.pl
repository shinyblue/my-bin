#!/usr/bin/perl -w
use strict;
die("usage: $0 template_file [template_file ...]\nor $0 --help\n") unless ( $#ARGV>-1 );

die(<<EOF
Usage:  $0 template_file [template_file ...]
Creates php files by concatenating a list of other files together.
* files are joined with no EOLs between them, so as to not start output
  between a list of files providing code.
* will not overwrite existing files, unless they were previously created by 
  this script.

Format of Template files:

* Lines starting with # are treated as comments and ignored.
* Indentation is not allowed.
* First line identifies file and must be:
	# phpTemplate
* Next line identifies file to be created. 
* Rest of lines are list of files to cat together.
* all paths should be relative to the directory that 
  contains the template file itself.

Example file: (ignore indentation)
	# phpTemplate
	# will create
	./relative/path/to/file/tocreate.php
	# Now the files:
	./relative/path/to/file1.chunk.php
	./relative/path/to/file2.chunk.php
	./relative/path/to/file3.chunk.php

EOF
	) if ( $ARGV[0] eq '--help' || $ARGV[0] eq '-h' );

	



chomp(my $cwd = `pwd`);

my @errors;
for my $file (@ARGV)
{
	print "Processing $file\n";
	if (! open (TPL, $file))
	{
		push @errors, "Failed to read: $file so could not create library\n";
		next;
	}
	my @parts = (<TPL>);
	close TPL;

	# check first line
	chomp( $_ = $parts[0] );
	if (! ( $#parts>-1 && ($_ eq '# phpTemplate' ) ))
	{
		push @errors, "Ignored $file as not a phpTemplate file (doesn't begin \"# phpTemplate\"\n";
		next;
	}

	# strip comments
	my @newParts = ();
	foreach (@parts) { push @newParts, $_ unless m/^#/ ;}
	@parts=@newParts;

	if ($#parts<1)
	{
		push @errors, "File $file is empty (or pretty much)! 
			Library not updated/created\n";
		next;
	}
	my $newFile = shift @parts;
	chomp $newFile;
	$newFile =~ s/'/\\'/;

	# change to the directory this file is in.
	my $wd = $file;
	# prepend ./ unless start from / or ./ or ../
	$wd = "./$wd" unless ( $wd =~ m{^[/.]} );
	# remove part after last /
	$wd =~ s{^(.*\/).+$}{$1};
	unless (chdir $wd) 
	{	
		push @errors, "couldn't change to directory $wd! file $file ignored.";
		next;
	}

	# check file to write. If it exists but doesn't start 
	# '<?php /* Created by compilePhpTemplates'
	# then bomb out.
	if (-r "$newFile")
	{
		open NF, $newFile;
		$_ = <NF>;
		close NF;
		unless ( m{^<\?php /\* Created by compilePhpTemplates} )
		{
			push @errors, "File $wd$newFile was not created by me, so I won't overwrite it. Remove the file if you want it recreated.\n";
			next;
		}
	}


	# open file to write
	unless (open NF, ">$newFile")
	{
		push @errors, "couldn't open $newFile for writing.\n";
		next;
	}

	# print header
	# Nb. there should be absolutely nothing between the chunks,
	#     no EOLS, for example.
	chomp ($_ = `pwd`);
	print NF "<?php /* Created by compilePhpTemplates.pl\n\txxx Do NOT edit this file! xxx\n\tCreated from: $_/$file\n\n\tvim:ft=text\n\t*/ ?>";
	
	# append each file
	my $success=1;
	foreach (@parts)
	{
		chomp;
		unless (open INFILE, $_)
		{
			push @errors, "couldn't open $_ for reading. $newFile will be incomplete!\n";
			$success=0;
			last;
		}
		my @infile = (<INFILE>);
		close INFILE;
		# chomp last line of INFILE
		chomp $infile[ $#infile ] if ($#infile>-1);
		print NF @infile;
	}
	close NF;

	# go back to original directory
	chdir $cwd;
	unless ($success)
	{
		push @errors, "Failed command while processing $file: '$newFile'\n";
		next;
	}
	else 
	{
		print STDOUT "\tCreated $wd$newFile\n";
	}
}
if ( $#errors>-1 )
{
	print STDERR "Errors:\n" . join '', @errors;
	exit 1;
}
else { exit 0; }

